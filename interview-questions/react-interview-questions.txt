28.10.25
Qn) If you'd like to use an existing component as a black box for composing another component's functionality, which technique is the most likely solution to the problem?
a) lifting state to the parent
b) inheritance
c) using a higher-order component
d) using a portal
e) using context

my-answer C

- A Higher-Order Component (HOC) is a function that takes a component and returns a new component.
- Its used when you want to reuse component logic without modifying the component itself, treating it as a black box. 
- This allows composition of behaviour around existing components

ToDo
- create a higher order component and use it

function withLogger(WrappedComponent) {
  return function EnhancedComponent(props) {
    console.log("Props received:", props);
    return <WrappedComponent {...props} />;
  };
}

const User = (props) => <div>Hello {props.name}</div>;
const UserWithLogger = withLogger(User);

- Here, User is the black box, and withLogger adds extra functionality without touching User.



ToDo
10 Common React Interview Questions
What are React Hooks?
Explain useState, useEffect, and why Hooks were introduced.
What’s the difference between a controlled and uncontrolled component?
Explain the Virtual DOM and how React uses it to optimize rendering.
What is the purpose of useMemo and useCallback?
What is reconciliation in React?
How does React’s Context API differ from Redux?
What’s the difference between React.memo and useMemo?
Explain the difference between props and state.
How would you handle side effects in React components?
What is lazy loading and how do you implement it in React?


Qn) In the below code, how many times will the Child component render? Enter the number of times as an integer in the answer field
const Child = () => <div>I'm the child...</div>

const Parent = () => {
    const [status, setStatus] = useState("clean");

    const load = async () => {
        const response = await new Promise(resolve => 
            setTimeout(resolve, 1000, {data: "dirty})
        );
        setStatus(response.data);
    };
    
    useEffect(() => {
        load();
    }, []);

    return (
        <div>
            <div>{status}</div>
            <Child />
        </div>
    );
};

ReactDOM.render(<Parent />, document.body);

my-answer 1
correct-answer 2

explanation
- number one note that the first render happens before the useEffect runs.
- the component Parent renders for the first time and status is clean initially. the useEffect runs after the first render
clean
I'm the child...
- in useEffect, load is called. init, we simulate an async API call
- after one second, the promise resolves with { data: "dirty" }
- then the useEffect is updated
- when setStatus dirty runs, react detects the state change and re-renders Parent component with the new state
dirty
I'm the child...
Concept being tested:
React re-renders children when their parent re-renders, unless they are memoized.
- child being a function component is not memoized. 
- everytime parent re-renders, react also calls Child() again
- if we wrapped child like this, it would only render once, since its props never change
const Child = React.memo(() => <div>I'm the child...</div>);
1. Render phase (synchronous) - react calls your component function. 
2. Commit phase - DOM update. - the UI
3. Effect phase (asynchronous) - useEffect
4. State Update - rerender


Qn) In the following component, which line of code needs to change in order to ensure that the component is rendered twice? Enter the line number only in the answer field
1const Example = () => {
2    const [words, setWords] = useState([]);
3
4    const loadWords = async () => {
5        const response = await new Promise(resolve => 
6            setTimeout(resolve, 2000, {data: [
7                "apples", "bananas", "cherries"
8            ]})
9        );
10        setWords(response.data);
11    );
12
13    useEffect(() => {
14        loadWords();
15    }, [words]);
16
17    return (
18        <>
19            {words.length
20                ? <ul>
21                    {words.map((e,i) => 
22                        <li key={i + e}>{e}</li>
23                    )}
24                    </ul>
25                : <Spinner />
26            }
27        </>
28    );
29};

my-answer 15

explanation
- initial render words = []
- react calls useEffect (since it always runs after the first render)
- it calls loadWords
- inside loadWords(), after 2 seconds, setWords(response.data) updates the state
- any state update triggers a re-render
- react sees words changed from [] to ["apples","bananas","cherries"]
- because words changed, the effect runs again after the re-render
- which calls loadWords() again which sets words again creating an infinite loop
Change line 15 to:
}, []);  // runs only once on mount


Qn) 
What's wrong with the following code snippet? Select all that apply
const Example = () => {
    const [words, setWords] = useState([]);

.    useEffect(() => 
        fetch("https://www.example.com/endpoint")
        .then(response => setWords(response.data))
        .catch(err => console.error(err))
.    , []);

.    const handleClick = e => {
        fetch("https://www.example.com/endpoint")
            .catch(err => console.error(err))
.        ;
    };

    return (
        <>
            {words.length
                ? <ul>
                    {words.map((e,i) => 
                        <>
                            <li key={i + e}>{e}</li>
                            <button onClick={handleClick}>Click here</button>
                        </>
                    )}
                </ul>
            : <p> Loading... </p>
        }
        </>
    );
};


answer and explanation
- missing .json() parsing on fetch()
fetch("https://www.example.com/endpoint")
        .then(response => setWords(response.data))
 - fetch() returns a response object not the JSON data directly
 - because it doesnt have a response.data property
 - we need to call response.json() first
correct code
fetch("https://www.example.com/endpoint")
  .then(res => res.json())
  .then(data => setWords(data))
  .catch(err => console.error(err));
- improper arrow function syntax in useEffect
 - you use parenthesis () instead of curly braces {} for the arrow function body
 - this means the function returns the results of fetch() (a promise) not undefined
 - react doesn't expect effects to return Promises. it expects nothing or a cleanedup function
useEffect(() => {
  fetch("https://www.example.com/endpoint")
    .then(res => res.json())
    .then(data => setWords(data))
    .catch(err => console.error(err));
}, []);
 - invaid element structure inside map() function
 - you cant put multiple elements inside a fragmant without a key when mapping
 - react will warn: each child in a list should have a unique key prop
 - the key must be on the topmost element returned from .map()
{words.map((e, i) => (
  <React.Fragment key={i + e}>
    <li>{e}</li>
    <button onClick={handleClick}>Click here</button>
  </React.Fragment>
))}
 - Button placement is illogial
 - move the button outside of the map
<ul>
  {words.map((e,i) => <li key={i + e}>{e}</li>)}
</ul>
<button onClick={handleClick}>Click here</button>

Qn) Error boundaries are components which are used to catch errors thrown only by their immediate children components
a) true 
f) false

my-answer true

explanation
- error boundaries in react are special components that catch JavaScript errors in their child component tree during:
 - rendering
 - lifecycle methods
 - constructors of their children
- they cannot chatch errors inside themselves only in their immediate and deeper child components
class ErrorBoundary extends React.Component {
    constructor(props) {
        super(props);
        this.state = { hasError: false };
    }

    state getDerivedStateFromError(error) {
        return { hasError: true };
    }

    componentDidCatch(error, info) {
        console.error("Error caught by boundary:", error);
    }

    render() {
        if (this.state.hasError) {
            return <h2>Something went wrong. </h2>;
        }
        return this.props.children;
    }
}
usage
<ErrorBoundary>
    <BuggyComponent />
</ErrorBoundary>

Limitations — Error Boundaries do not catch:
- Errors in event handlers
- Asynchronous code (e.g. setTimeout, fetch)
- Server-side rendering
- Errors inside the Error Boundary itself
<button onClick={() => { throw new Error("Oops"); }}>
  Click me
</button>
This error won’t be caught by an error boundary — you’d need a regular try...catch around the event handler.

Qn) Which of the following errors will NOT be caught by an error boundary
(select all that apply)
a) Errors thrown inside event handlers
b) Errors during server-side rendering
c) Errors inside asynchronous code like setTimeout
d) Errors thrown by a child component's render method

my-answer a,b,c

explanation
- Error boundaries can only catch errors in 
 - Their child components' render phase (during render-time)
 - Lifecycle methods
 - Constructors

Qn) Which lifecycle method(s) can you use to handle errors in a class-based error boundary?
a) componentDidCatch
b) getDerivedStateFromError
c) Both a and b
d) componentDidUpdate

my-answer i dont really know and i dont want to guess
correct-answer c

class ErrorBoundary extends React.Component {
    constructor(props) {
        super(props);
        this.state = { hasError: false };
    }

    static getDerivedStateFromError(error) {
        // update state so fallback UI renders
        return { hasError: true };
    }

    componentDidCatch(error, info) {
        // log the error or report it
        console.log("Caught by Error Boundary:", error, info);
    }

    render() {
        if (this.state.hasError) {
            return <h2>Something went wrong. </h2>
        }
        return this.props.children;
    }
}
- getDerivedStateFromError(error) - Updates the state before rendering the fallback UI
- componentDidCatch(error, info) - Logs the error or performs side effects (send to logging services)
 
Qn) You have the following code:
<ErrorBoundary>
    <ComponentA />
    <ComponentB />
</ErrorBoundary>
If ComponentA throws an error during render, what happens?
a) The whole page crashes
b) Only ComponentA is replaced by the fallback UI
c) Both ComponentA and ComponentB are replaced by the fallback UI
d) Nothing - ErrorBoundary doesn't catch it

my-answer again im sorry i dont really know. please teach me
correct-answer C

explanation
- when any child component throws an error, the entire subtree inside the errorBoundary fails. 
- React stops rendering all siblings (ComponentB in this case)
- The errorBoundary replaces everything inside it with its fallback UI

Qn) You're using function components. Can you create an error boundary using only hooks (no classes)?
a) Yes, using useEffect
b) Yes, using useErrorBoundary build into React
c) No, React only supports class-based error boundaries
d) Yes, with useErrorBoundary from a third-party library like react-error-boundary

my-answer im sorry i again dont know
correct-answer D

explanation
- React itself as of now (18,19) does not have built-in hooks for error boundaries
- Error boundaries must be class components, because React's error-handling mechanism is based on lifecycle methods (componentDidCatch)
- However, libraries like react-error-boundary offer a useErrorBoundary() hook and a <ErrorBoundary> wrapper for function components.
import { ErrorBoundary, useErrorBoundary } from "react-error-boundary";

function MyComponent() {
    const { showBoundary } = useErrorBoundary();

    return <button onClick={() => showBoundary(new Error("Oops!"))}>Trigger</button>;

so,
useEffect cant catch render errors
there's no build in useErrorBoundary
Not possible natively in React (only with classes)
its possible via a third party hook

- Lifecycle methods are special methods in React class components that let you run code at specific points in a component's life cycle from mounting, updating, to unmounting
- the three phases of a class component
Phase - Purpose - Example methods
a) Mounting (birth) - when component is first added to the DOM - constructor() -> componentDidMount()
b) Updating (growth) - when props or state change - shouldComponentUpdate(), componentDidUpdate()
c) Unmounting (death) - When component is removed from DOM - componentWillUnmount()
d) Error Handling - when a descendant throws and error - static getDerivedStateFromError(), componentDidCatch()

class Example extends React.Component {
    constructor(props) {
        super(props);
        this.state = { count: 0 };
        console.log('Constructor');
    }
    componentDidMount() {
        console.log('Mounted');
    }
    componentDidUpdate() {
        console.log('Updated');
    }
    componentWillUnmount() {
        console.log('Unmounted');
    }

    static getDerivedStateFromError(error) {
        console.log('Error caught (state update)');
        return { hasError: true };
    }

    componentDidCatch(error, info) {
        console.log('Error caught (side effect or log)');
    }

    render() {
        console.log('Render');
        return <button onClick={() => this.setState({ count: this.state.count + 1 })}>Click</button>;
    }
}

code

class ErrorBoundary extends React.Component {
    state = { hasError: false };

    static getDerivedStateFromError(error) {
        return { hasError: true };
    }

    componentDidCatch(error, info) {
        console.error("Error caught:", error);
    }

    render() {
        if (this.state.hasError) return <h2>Something went wrong</h2>;
        return this.props.children;
    }
}

in functional components
- hooks like useEffect cannot catch render errors.
- they can only catch errors inside the event callback eg try/catch inside useEffect - not the render tree
- React does not provide a built-in useErrorBoundary() hook
- however, third-party libraries like react-error-boundary lets you use error boundaries with function components

code
import { ErrorBoundary } from "react-error-boundary";

function Fallback({ error }) {
    return <p> Oops: {error.message}</p>;
}

function Problematic() {
    throw new Error("Crashed!");
}

export default function App() {
    return (
        <ErrorBoundary FallbackComponent={Fallback}>
            <Problematic />
        </ErrorBoundary>
    );
}


| Feature         | Class Components          | Function Components           

| **Syntax**      | ES6 class                 | Plain JS function             
| **State**       | `this.state`, `this.setState()`  | `useState()`                  
| **Lifecycle methods**  | Explicit methods (`componentDidMount`, etc.) | Hooks (`useEffect`)
| **Refs**      | `React.createRef()`         | `useRef()`                    
| **Context**   | `contextType`               | `useContext()`                
| **Error Boundaries**  | ✅ Supported (via lifecycle methods) | ❌ Not built-in (need library) |
| **Performance**    | Slightly heavier      | Generally lighter           
| **Recommended by React team** | Legacy      | ✅ Modern standard        


Qn)
Choose the components type(s) that best describes this code.
cost FilePicker = () => {
    const fileInput = React.createRef();

    const handleSubmit = evt => {
        evt.preventDefault();
        console.log(fileInput.current.files[0].name);
    };

    return (
        <form onSubmit={handleSubmit}>
            <label>
                Upload file: 
                <input type="file" ref={fileInput} />
            </label>
            <button type="submit">Submit</button>
        </form>
    );
};
a) controlled component
b) uncontrolled component
c) higer-order component
d) pure component
e) functional component
f) class component
g) suspense component

my-answer e,d

correct-answer e,b

explanation
- a controlled component is one where the input value is controlled by React State like value={stateVar} and onChange={setState}
- here the <input type="file" /> does not use useState or onChange
- instead, it uses a ref (fileInput.current.files) to directly access the DOM value.
- an uncontrolled component is one where the DOM (Document Object Model) manages its own internal state.
- the reason why its not a pure component, a pureComponent is a class-based optimization that does shallow comparison of props/state.
- Function components dont become pure unless wrapped in React.memo()

- A controlled component is one where React controls the form input's value via state.
- the value displayed in the DOM always comes from React's state.
- If a user types something, the change goes through React first

code
const NameForm = () => {
    const [name, setName] = useState('');

    return (
        <input type="text" value={name} onChange={e => setName(e.target.value)} />
    );
};
- if you see value={state} its controlled
- React knows the value at all times 

2. Uncontrolled Component
- an uncontrolled component lets the DOM itself control the input value
- React doesnt store it, you can just access it via a ref when needed

code
const NameForm = () => {
    const inputRef = useRef();

    const handleSubmit = () => {
        alert(inputRef.current.value);
    };

    return (
        <>
            <input type="text" ref={inputRef} />
            <button onClick={handleSubmit}>Submit</button>
        </>
    );
};
- if you see ref not value, or onChange, its uncontrolled

3. Higher-Order Component HOC
- a higher-order component is a function that takes a component and returns a new one - adding extra functionality.
- it wraps another component

code
function withLogger(WrappedComponent) {
    return function(props) {
        console.log("Rendering", WrappedComponent.name);
        return <WrappedComponent {...props} />;
    };
}

const EnhandedButton = withLogger(Button);

- if you see function withLogger(WrappedComponent) thats a HOC

4. Pure Component
- A pure component automatically skips re-rendering when its props or state hasnt changed (it does a shallow comparison)
- this is a performance optimization

code
class MyComponent extends React.PureComponent {
    render() {
        console.log("Rendered");
        return <div>{this.props.text}</div>;
    }
}
- it wount rerender unless this.props.text changes
- for function component, the equivalent is

code
const MyComponent = React.memo(({ text }) => <div>{text}</div>);

- if you see PureComponent(class) or React.memo(function) its pure

5. Functional Component
- a functional component is a function that returns JSX
- its the modern way of writing React components using hooks like useState, useEffect

code
const Greeting = ({ name }) => <h1> Hello, {name}</h1>;

- if you see const Component = () => {} its a functional component

6. Class Component
- Before hooks, React used class components ES6 classes that extend React.Component and use lifecycle methods like componentDidMount

code
class Greeting extends React.Component {
    render() {
        return <h1> Hello, {this.props.name}<h1>;
    }
}

7. Suspense Component
- Suspense is a special build-in react component that allows you to wait for something (like data or lazy-loaded code) before showing UI
- it works with features like React.lazy() and the new use hook in React 19

code
const LazyProfile = React.lazy(() => import('./Profile'));

function App() {
    return (
        <Suspense fallback={<div>Loading...</div>}>
            <LazyProfile />
        </Suspense>
    );
}

Qn) If you have a complex animation which requires manipulation of a <canvas> element, which React feature is the most likely solution to the problem
a) portals
b) context
c) refs
d) higher-order components
d) fragments

my-answer: if using elimination method. it cant be c, cant also be d. but i also dont know even what they are talking about neither the multiple choices apart from c and d. explain well all. and which topic in react this is

correct-answer: c

explanation
- The HTML <canvas> element is used to draw graphics on the fly via JavaScript.
- The canvas element is only a container for graphics which you use JavaScript to draw the graphics
- so here, youre doing something like a game or chart using HTML. You'll need direct access to the actual DOM elements to call drawing methods like
canvas.getContext('2d').fillRect(...);
- In react the normal way is declarative, you describe what you render. But here you need to imperatively manipulate the DOM element. so you use refs
- a ref in React gives you direct access to a DOM element or a component instance - bypassing React's declarative rendering
- When we talk about React's declarative rendering, we're referring to the way React updates the UI automatically based on state or props rather than manipulating the DOM
- Declarative rendering means, you declare what the UI should look like given some state, and React takes care of how to update the DOM to make it match. You dont tell React how to draw or change the UI.
- But now with canvas, you cant declare what to draw with JSX because canva doesnt work that way. its just a blank surface. you need to imperatively use drawing commands like 
ctx.fillRect(20,20,150,100);

code 
import {useRef, useEffect} from "react";

const CanvasAnimation = () => {
    const canvasRef = useRef(null);

    useEffect(() => {
        const ctx = canvasRef.current.getContext("2d");
        ctx.fillStyle = "red";
        ctx.fillRect(20,20,150,100);
    }, []);

    return <canvas ref={canvasRef} width={300} height={200}></canvas>;
    };

A) Portals
- Portals lets you render children into a different part of the DOM tree, outside the parent hierachy. eg modals, tooltips, dropdowns that need to escape a parent's overflow:hidden or z-index

code
ReactDOM.createPoral(
    <div className="modal">I'm outside the main root</div>;
    document.getElementById('modal-root'0
);
- Portals are used for DOM placement, not manipulation

B) Context
- context lets you share global data (like theme, auth, or language) without passing props manually

code
const ThemeContext = React.createContext();

const App = () => (
    <ThemeContext.Provider value="dark">
        <Toolbar />
    </ThemeContext.Provider>
);
- context is for data flow not DOM manipulation

E) Fragments
- fragments lets you return multiple elements without adding an extra DOM node.
return (
<>
    <h1>Hello</h1>
    <p>World</p>
</>
);

Qn) Your component has grown too large and contains a useEffect call that supports a requestAnimationFrame loop. Which React feature is the most likely solution to the problem?
a) writing a custom hook for the RAF loop
b) memoizing the RAF loop
c) using composition to create a separate component to handle the RAF loop
d) using a generic helper utility file for the RAF loop

my-answer

correct-answer: a

explanation:
step 1: what is requestAnimationFrame (RAF)
- requestAnimationFrame is a browser API not react-specific used to create smooth and efficient animations.
- it tells the browser "hey, before you paint the next frame, call this function"
- the browser tries todo this roughly 60 times per second 60FPS
- instead of manually using setInterval which can stutter or go off-sync, requestAnimationFrame runs in perfect rhythm with the browser's painting cycle.

code vanilla JavaScript
let position = 0;
function moveBox() {
    position += 1;
    box.style.transform = `translateX(${position}px)`;
    requestAnimationFrame(moveBox);
}
requestAnimationFrame(moveBox);
- the browser calls moveBox() before every repaint.
- thats how games, physics, and smooth animations run.
step 2: How this looks inside react
- imagine you have a React component with a useEffect that runs a RAF loop.

code
const MovingBox = () => {
    const boxRef = useRef();

    useEffect(() => {
        let frameId;
        let position = 0;

        const animate = () => {
            position += 1;
            boxRef.current.style.transform = `translateX(${position}px)`;
            frameId = requestAnimationFrame(animate);
        };

        frameId = requestAnimationFrame(animate);

        return () => cancelAnimationFrame(frameId);
    }, [];

    return <div ref={boxRef} className="box" />;
};
- works fine but if your component grows large, handling lots of state, logic, effects and rendering this code makes it bloated and harder to maintain
step 3	
- so the component is doing too much (rendering + animation)
- it breaks separation of concerns - reacts recommends each part have one responsibility
- this is an architecture / code organization problem not performance yet
step 4
so, you write a custom hook for the RAF loop
- a custom hook lets you extract reusable login (like the RAF loop) out of component while keeping its own internal state, effects and lifecycle handling.

code
function useAnimationFrame(callback) {
    const requestRef = useRef();

    const animate = time => {
        callback(time);
        requestRef.current = requestAnimationFrame(animate);
    };

    useEffect(() => {
        requestRef.current = requestAnimationFrame(animae);
        return () => cancelAnimationFrame(requestRef.current);
    }, []);
}
then in your component
const Box = () => {
    const ref = useRef();

    useAnimationFrame(() => {
        ref.current.style.transform = `rotate(${Date.now() / 10}deg)`;
    });

    return <div ref={ref} className="box" />;
};

Qn) Consider the following code snippet
const Foo = React.lazy(() => import("./Bar"));
Which concept does this best illustrate
a) code splitting
b) context
c) higher-order components
d) forwarding refs
e) portals

my-answer: trick question this one. coz answer in my opinion is not b, context is for using global states, not c a HOC is for wrapping other components, e its not a portal because portals are for rendering children into different parts of the dom say when you want to use a modal. so i dont really know

correct-answer: A

explanation:
- this is react's performance optimization
- React's React.lazy is a built-in function that allows you to dynamically imports a component.
- the Bar component isnt loaded when your app starts.
- its only loaded when you actually render <Foo />
- so the browser doesnt download the code for Bar until Foo  is needed.
- this is lazy loading. lazy loading is a part of a bigger concept called code splitting.

Qn) JSX doesn't sanitize text contents by default. If you have contents that could contain data that's from an untrusted source, it's important to escape it manually
a) true
b) false

my-answer:

correct-answer: b

explanation:
topic is react security & JSX Renderin behaviour  (XSS (Cross-Site Scripting), Data sanitization, dangerouslySetInnerHTML, safe rendering of untrusted data)
- Sanitizing means cleansing or escaping data so that it cannot run malicious code inside your app.
- think of it as protecting your users from hackers who might try to inject harmful scripts.
eg,

code
<div>{userComment}</div>

- imagine someone posts this as a comment

code
<script>alert('Hacked!')</script>

- if react didnt sanitize that, the browser would execute that script. This is called XSS Cross-Site Scripting a major web security flaw
- so now, react automatically escapes (sanitizes) everything inside {} in JSX.
- so if the user writes that script, react will render it as a text not as read Javascript
- react will not sanitize only when you manually tell it to inject raw HTML, say

code
<div dangerouslySetInnerHTML={{ __html: userComment }} />
- this bypasses reacts safety and if the userComment has a script, then boom. your vulnerable
- thats why its called dangerouslySetInnerHTML
- use it only if;
- you fully trust the content or youve sanitized it yourself with a library like DOMPurify

Qn) You can use custom attributes on nodes in JSX, but they have to be entirely lowercase
a) true
b) false

my-answer: weh, false

correct-answer: b

explanation:
Topic - JSX, DOM Attributes, custom props
- when you write JSX like

code
<div className="box" data-user-id="123"></div>

- react compiles it to something like
React.createElement('div', {className: 'box', 'data-user-id': '123' });
- so you can add custom attributes on nodes in JSX but really doesnt have to be lowecase
<div data-user="123" />      // ✅ Standard custom data attribute
<div customattr="hello" />   // ✅ Works fine in React 16+
<div customAttr="hello" />   // ✅ Also works, React won’t change the case
So — it’s not true that they “must be entirely lowercase.”
- React uses JavaScript naming conventions not HTML's for its attributes
HTML Attribute	 JSX Equivalent	  Why
class	         className	  Because class is a reserved word in JavaScript
for	         htmlFor	  Because for is a JS keyword, and React expects camelCase for DOM properties
tabindex	 tabIndex	  Follows camelCase for DOM property names
onclick	         onClick	  Event handlers are camelCase
maxlength	 maxLength	  DOM property is camelCase
readonly	 readOnly	  Same reason

HTML Event	JSX Equivalent
onclick	        onClick
onchange	onChange
onfocus	        onFocus
onblur	        onBlur
onmouseover	onMouseOver
3. Boolean Attributes
In HTML you might write:
<input disabled>
In JSX, you must provide an explicit boolean:
<input disabled={true} />
or shorthand:
<input disabled />
✅ React interprets disabled without value as true.
Inline Styles
In HTML:
<div style="color: red; background-color: blue;"></div>
In JSX:
<div style={{ color: 'red', backgroundColor: 'blue' }}></div>
7. Self-Closing Tags
JSX requires self-closing syntax for void elements:
<br /> <img /> <input /> <hr /> <meta /> <link />
❌ This would fail:
<br>
8. Custom Components (Capitalized Names)
React differentiates between:
Lowercase names → built-in HTML elements (div, span)
Uppercase names → your custom React components (Button, Card)
Example:
function Card() { return <div>Hi</div>; }
<Card />  // ✅ React component
<div />   // ✅ HTML element

Qn) PureComponents is useful when you have deeply-nested, complex state to avoid updates
a) true
b) false

my-answer: what i know is that a pureComponent is used when one wants to do a shallow comparison. it would skip rendering if the props havent changed. so i dont know if its useful in deeply-nested states. but i feel like its work really is to avoid unnecessary updates. so id go with a

correct-answer: b

explanation
-  a purecomponent is a react class component that automatically implements a shouldComponentUpdate() todo a shallow comparison between props and state. if neither props nor state appear to change, it skips rerendering
- a purecomponent only does a shallow comparison meaning it checks references not deep nested values
- so if you have

code
state = {
    user: {name: "Immanuel", age: 25}
};
- and you update it like this
this.state.user.name = "John"; // mutation, same reference
this.setState({ user: this.state.user });
- react sees the same reference and assumes nothing changed. and skipps render even though the nested name changed.
- thats why purecomponent is not useful for deeply-nested or complex states.
- you'd need either 
- immutable stat updates or a deep comparizon

Qn) Consider the following code
<Foobar autocomplete />
What's the value of autocomplete

my-answer: true. (haha, you see when you explain to me something well i'll get the next question. thats what i want you todo. because this weve already covered in your excellent and succinct explanations

correct-answer: true

explanation:
- the presence of the attribute means true.
so its same as
<Foobar autocomplete={false} />
<input autocomplete>        ✅ true
<input>                     ✅ false (no autocomplete attr)

28.10.25
React Testing Library
- test types
   test type - what it checks - example
i) Unit test - Does this function or component behave as expected? - Does Button show the right text
ii) Integration test - Do multiple components work together? - Does clicking "submit" trigger the form handler?
iii) End-to-end (E2E) - Does the whole appwork from the user's perspective - Can a user log in and see their dashboard

- common testing libraries
i) Jest (the test runner)
- is the core testing framework for React.
- comes preconfigured with Create React App
- ati you almost always use jest, no matther what library you pick.

code
test('adds 1 + 2 equals 3', () => {
    expect(1 + 2).toBe(3);
})

ii) React Testing Library (RTL) - modern standard
- Built ontop of Jest
- focuses on how users interact with your app, not the internal implementation
- encourages testing behaviour, not structure
- RTL simulates real user interactions (typing, clicking, seeing text)

code
import { render, screen, fireEvent } from "@testing-library/react";
import App from './App';

test('button click shows message', () => {
    render(<App />);
    fireEvent.click(screen.getByText('Show'));
    expect(screen.getByText('Hello Immanuel')).toBeInTheDocument();
});

command to download
> npm install --save-dev @testing-library/react @testing-library/jest-dom

code
import { render, screen } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import App from './App';

test('displays welcome message', async () => {
    render(<App />);
    await userEvent.click(screen.getByText('Show Message'));
    expect(screen.getByText('Welcome, Immanuel!)).toBeInTheDocument();
});

Qn) React Testing Library differs from Enzyme in that it helps you test implementation details to ensure the internals of the component behave exactly as they should
a) true
b) false

my-answer: b ive seen that RTL test how users interact with the app and not the internal details

correct-answer: b

explanation:
Enzyme tests the intenals. the implementation details
React Testing Library 
"“The more your tests resemble how your software is used, the more confidence they can give you.”
- RTL focuses on what the user sees and does, not on the implementation.

code
render(<Counter />);
fireEvent.click(screen.getByText('Increment'));
expect(screen.getByTex('Count: 1')).toBeInTheDocument();
- here we test behavior. Not how the component updates state, but whether the output and UI respond correctly.
- RTF helps you test user-facing behavour not implementation details

Qn) screen queries are generally preferred over render queries in RTL
a) true
b) false

my-answer:

correct-answer: a

explanation:
this question falls under React Testing Library fundamentals - specifically:
"Queries and best practices for accessing elements in the DOM during tests"
- when you write tests, you first render your component, then query (find) elements inside it to test their behavior.

step 1: what render() does
when you call:

code
render(<MyComponent />);
RTL:
-creates a virtual DOM for your component
-returns several query functions that you can use to find elements eg getByText,getByRole
-also registers your rendered component inside a global object called screen.
step 2: what are render queries
- these are queries returned directly from the render() function

code
const { getByText } = render(<App />);
const button = getByTest('Submit);
- works but can get messy when you have many tests because you have to destructure from render() in each test, and its not obvious which screen is being referred to
step 3: what are screen queries
-instead of destructuring from render, RTL lets you use the global screen object.

code
render(<App />);
const button = screen.getByText('Submit);
- screen object is like a shortcut. it automatically points to the current rendered DOM

Common Query Types
Query - Example - Use case
getByText - screen.getByText("Hello") - Find visible text
getByRole - screen.getByRole("button") - Find by accessibility role
getByLabelText - screen.getByLabelText("Email") - For form inputs
getByPlaceholderText - screen.getByPlaceholderText("Search...") - For input placeholders
getByTestId - screen.getByTestId("submit-btn") - When no better selector exists
queryBy - scree.queryByText("Error") - Return null if not found
findBy - await screen.findByText("Loaded!") - For async elements

Qn) It's important to add cleanup() to an afterEach block since RTL doesn't do this automatically in a typical testing setup.
a) true
b) false

my-answer: i honestly dont know

correct-answer: b

explanation:
when you call render(<Component />) in a test, RTL mounts your component in a simulated DOM provided by jsdom.
- after each test runs, you usually want to remove that DOM so that the next test starts afresh - no leftover elements, no state leaks, no memory issues.
- now, before react testing library version 9+ you had to call cleanup() manually inside afterEach() otherwise the rendered component would persist between tests. 
- since react testing library v9, and Jest setups like create React App or vite, cleanup() runs automatically after each test.
- no manual cleanup required
- so you can have

code
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders', () => {
    render(<App />);
    expect(screen.getByText(/hello/i)).toBeInTheDocument();
});

Qn) The RTL philosophy is to not test implementation details. One drawback to this is that 100% code coverage is typically impossible
a) true
b) false

my-answer: i know that RTL tests user interface not implementation details but i dont know if it covers everything

correct-answer: a

explanation:
- RTL tests outcomes not internal mechanics
- it does not test internal state, functions or hooks directly, rather it tests only what the user can see or do eg clicks, typing
- code coverage is a metric showing how much of your code was executed during testing.
- tools like jest --coverage measure this
- eg 100% line coverage means every line of code run at least once during a test
- BUT, and this is key coverage does not mean meaningful testing. you could hit every line but still not validate correct behavior.
- since RTL intentionally ignores implementation details, some parts of your code might never be directly triggered by user interactions
eg

code
function computeDiscount(price) {
    return price * 0.9;
}

function Cart(){
    const total - computeDiscount(100);
    return <p>Total: {total}</p>;
}
RTL test
expect(screen.getByText('Total: 90')).toBeInTheDocument();

Qn) When testing custom hooks directly, which rendering call would help eliminate the necessity of a component wrapper

my-answer:

correct-answer: renderHook()

explanation:
- hooks cant live alone
- react hooks like useState, useEffect or your custom useFetch can only be used inside function components.
- react will throw errors if you run them in isolation
- so when you want to test a hook, you must render it inside a component somehow. and this is where testing utilities come in.
step 2: the old way: wrapping a test component manually
- before specialised tools existed, people wrote something like this:

code 
function TestComponent() {
    const value = useCustomHook();
    return <p>{value}</p>;
}

render(<TestComponent />);
- this works but every time you need to test a single hook, you'll need and extra wrapper component.
step 3: the modern way -renderhook from RTL
- RTL provides a dedicated API for this

code
import { renderHook } from '@testing-library/react';

const { result } = renderHook(() => useCustomHook());
- now you dont need a manual wrapper - the hook runs in a tiny "virtual" component behind the scenes/
- now you can access
result.current -> the current value the hook returns
rerender() -> re-run the hook with new props.
waitForNextUpdate() -> wait for async hooks to finish
- hooks depend on React's lifecycle - so we cant call them directly like functions.
- renderHook creates a tiny "fake component" behind the scenes
so
this is same as that

code
const { result } = renderHook(() => useCounter());

code
function TestComponent() {
    const hookValue = useCounter();
    return null;
}

render(<TestComponent />);

Qn) Choose the selection ordering from most to least preferred, with most preferred towards the beginning (left) and least preferred towards the end(right) of the list
a) aria role, test id, text
b) aria role, text, test id
c) test id, aria role, text
d) test id, text, aria role
e) text, aria role, test id
f) text, test id, aria role

my-answer: manh ive not even seen anything like this. how will i pass an interview of equivalent nature if every question is new. but i know slowly this will go away. and what topic is this too? and what else do i need to know. after reading a little i guess e

correct-answer: b

explanation:
topic is query priority and accessibility best practices
- testing whether you know which queries to use first when finding elements in your tests.  
- RTL has a philosophy "The more your tests resemble how the app is used, the more confidence they can give you"
- this means you should query elements the way a read user or assistive technology would find them
step 2: what "query ordering" means
- when youre testing, you need to find an element before interacting with or asserting on it.

code
screen.getByText('Submit');
screen.getByRole('button', { name: /submit/i });
screen.getByTestId('submit-btn');
- from the React Testing Library docs
- always try to select elements the same way the user would find them
1. role getByRole('button', {name: /submit/i} ) - is most accessible matches to how assistive tech finds elements
2. test getByText('Submit') - matches what user visually sees
3. test ID getByestId('submit-btn') - not user-facing - only use when there is no other way

code 
<button aria-label="Send message">📨</button>
a screen reader will announce " Button, Send Message. if you test using the flag, getByText, it might break if you change the emoji but getByRole('button', {name : /send message/i}) will work

Full query hierachy from RTL docs
from most preferred to least preferred
1. getByRole
2. getByLabelText (for form inputs)
3. getByPlaceholderText
4. getByText
5. getByDisplayValue (fpr inputs showing value)
6. getByAltText (for images)
7. getByTitle
8. getByTestId (last resort)

Qn) Which matchers arent part of the base React Testing Library?
choose all correct answers below
a) .toBeDisabled()
b) .toBeInTheDocument()
c) .toHaveTextConent()
d) .toMatchSnapshot()

my-answer: i know definitly b is there. ive not seen a,c,d anywhere. but d feels correct if you are working with files and images i dont know. okay i really dont know

correct-answer: a,b,c,d (all of them are not part of the base React Testing Library)

explanation:
- a matcher is part of a test that asserts something.
- its what follows expect() in Jest or RTL tests

code
expect(button).toBeDisabled()
expect(link).toBeInTheDocument()
expect(title).toHaveTextContent('Hello world')

- base jest matchers come from jest itself are
toBe()
toEqual()
toContain()
toMatchSnapshot()

React Testing Library primarily utilizes Jest's built-in matchers and extends them with custom matchers provided by @testing-library/jest-dom.
Jest Matchers:
Jest provides a rich set of matchers for general value comparisons and assertions, including:
Equality: toBe(), toEqual(), toStrictEqual()
Truthiness: toBeTruthy(), toBeFalsy(), toBeNull(), toBeUndefined(), toBeDefined()
Numbers: toBeGreaterThan(), toBeLessThan(), toBeGreaterThanOrEqual(), toBeLessThanOrEqual(), toBeCloseTo()
Strings: toMatch(), toContain()
Arrays/Iterables: toContainEqual(), toHaveLength()
Objects: toHaveProperty(), toMatchObject()
Functions: toHaveBeenCalled(), toHaveBeenCalledTimes(), toHaveBeenCalledWith(), toHaveReturned(), toHaveReturnedTimes(), toHaveReturnedWith()
Exceptions: toThrow(), toThrowError()
Promises: resolves, rejects

- you can use them to even test plan JavaScript not just React.
- RTL itself doesn not include matchers directly. it relies on an addon package called 
@testing-library/jest-dom
- they have
.toBeInTheDocument()
.toBeDisabled()
.toHaveTextContent()
.toHaveAttribute()
.toBeVisible()

@testing-library/jest-dom Custom Matchers:
This library enhances Jest with DOM-specific matchers, making tests more readable and declarative when working with React components:
toBeInTheDocument(): Checks if an element is present in the document.
toBeVisible(): Checks if an element is visible to the user.
toBeDisabled(), toBeEnabled(): Checks the disabled/enabled state of form elements.
toBeChecked(), toBePartiallyChecked(): Checks the checked state of checkboxes/radio buttons.
toContainElement(), toContainHTML(): Checks if an element contains another element or specific HTML.
toHaveAttribute(), toHaveClass(), toHaveFocus(), toHaveStyle(): Checks for specific attributes, classes, focus state, or inline styles.
toHaveTextContent(): Checks the text content of an element.
toHaveValue(), toHaveDisplayValue(): Checks the value of form elements.
toBeEmptyDOMElement(): Checks if an element has no children.
toHaveAccessibleName(), toHaveAccessibleDescription(): Checks for accessible names and descriptions (e.g., from aria-label, alt text).
These matchers are used in conjunction with the expect() function, for example:
JavaScript

expect(screen.getByText('Submit')).toBeInTheDocument();
expect(screen.getByRole('button', { name: /submit/i })).toBeDisabled();
expect(screen.getByTestId('my-element')).toHaveTextContent('Hello');

- so as you realise, these markers come from Jest or @testing-library/jest-dom not RTL itself. and btw only d is from the jestCore the rest come from @testing-library/jest-dom

- RTL itself gives you 
render(), screen, fireEvent(), waitFor(), userEvent but these are not mathers.
- RTL provides queries not matchers.

Qn) What is @testing-library/jest-dom
its a library that extends Jest's expect() with DOM-aware matchers, like toBeInTheDocument() and toHaveTextContent() making tests more readable and aligned with how users see the app


wrong way - using eg getBy which is Synchronous
const { getByText } = render(<UserGreeting />);
expect(getByText("Hello Immanuel")).toBeInTheDocument();
// Fails immediately since its not yet rendered
correct way - using findBy which is Asynchronous
const { findByText } = render(<UserGreeting />);
const greeting = await findByText("Hello Immanuel");
expect(greeting).toBeInTheDocument();

Greetings.test.js
import { render, screen, waitFor } from "@testing-library/react";
import Greeting from "./Greeting";

test("getBy - finds existing element instantly", () => {
    render(<Greeting />);
    // the text loading appears immediately
    const loader = screen.getByText("Loading...");
    expect(loader).toBeInTheDocument();
});

// at this moment if you tried
// screen.getByText("Hello, Immanuel") it would throw an error

// queryBy
test("queryBy - Check element absense", () => {
    render(<Greeting />);
    // Hello Immanuel doesnt exist yet
    const greeting = screen.getByText("Hello Immanuel");
    expect(greeting).toBeNull();  // this is a safe check. it returns null
})

// findBy - asynchronous
test("findBy - returns a promise so you must wait for it", async () => {
    render(<Greeting />);
    const greeting = await screen.findByText("Hello Immanuel");
    expect(greeting).toBeInTheDocument();
});
// automatically retires for upto one second by default

// waitFor - waits for any condition you define
// use when you cant directly findByText but need to wait for some condition to become true
test("waitFor - wait for condition", async () => {
    render(<Greeting />);

    await waitFor(() => {
        expect(screen.getByText("Hello Immanuel")).toBeInTheDocument();
    });
});

example two

code
Greeting.js
export default function Greeting({ name }) {
    return (
        <div>
        <h1>Hello {name}</h1>
        <button disabled>Click me</button>
        </div>
    );  
}

- here is a test fine without jest-dom
Greetings.test.js
import { render, screen } from '@testing-library/react';
import Greeting from './Greeting';

test('renders greeting text', () => {
    render(<Greeting name="Immanuel" />);
    const heading = screen.getByText("Hello Immanuel");

    // these are jest base matchers only
    expect(heading).toBeTruthy();  // works
    expect(heading.textContent).toBe(Hello Immanuel);  // manual check

    // but this will fail
    // expect(heading).toBeInTheDocument();
    // expect(button).toBeDisabled();
    // because these matchers dont exist
})

- now using jest-dom
> npm install --save-dev @testing-library/jest-dom

SetupTests.js
import "@testing-library/jest-dom";
import { render, screen } from "@testing-library/react";
import Greeting from './Greeting';

test('renders greeting text', () => {
    render(<Greeting name="Immanuel" />);

    const heading = screen.getByText("Hello Immanuel");
    const button = screen.getByRole("button");

    // these can now work coz of @testing-library/jest-dom
    expect(heading).toBeInTheDocument();
    expect(button).toBeInTheDocument();
    expect(heading).toHaveTextContent("Hello Immanuel");
});

Matcher	What it checks
.toBeInTheDocument()	element exists in DOM
.toBeVisible()	visible to the user
.toBeDisabled()	disabled form control
.toHaveTextContent('text')	contains this text
.toHaveAttribute('attr', 'value')	has this attribute
.toHaveClass('classname')	has this CSS class
.toHaveValue('value')	has input value


Qn) If you use a getBy method, no expect assertion is strictly necessary
a) true
b) false

my-answer: i feel like a, because maybe before RTL 19 you had to expect but now it does internally. oh no my answering language grammah is also off. i want you to answer these questions in a manner i can get that language necessary for interviews or talk shows

correct-answer: a

explanation:
"When using getBy queries in RTL, an explicit expect() assertion isnt strictly required. The getby method itself throws an error if the element can't be found, which automatically fails the test. However in practice, most developers still include an expect() statement for clairty and readability"
- When you use a getBy query in React Testing Library, it immediately throws an error if the element cannot be found in the DOM.
- That behaviour alone is enough to fail the test. even if you never get to write the expect() statement. 

test("renders greeting message", () => {
    render(<Greeting />);

    screen.getByText("Hello Immanuel");
});
// if element doesnt exist you'll see, unable to find an element with the text: Hello Immanuel


// preferred
test("renders a greeting test with cleaner approach", () => {
    render(<Greeting name="Immanuel" />);

    expect(screen.getByText("Hello Immanuel")).toBeInTheDocument();
});

Qn) If you want to assert that an element does not exist in the document, queryBy is the preferred selection method
a) True
b) False

my-answer: 

correct-answer: true

explanation:
"Yes, true. The queryBy family of queries in React Testing Library RTL is specifically designed for checking whether elements donot exist in the DOM. Unlike getBy which throws an error if it doesnt find an element, queryBy simply returns null, which makes it ideal for safe assertions about absence — for exaple, verifying that a loading spinner or an error message has disappeared."

code 
test("the error message should not be visibe initially", () => {
    render(<Greeting />);
    const errorMessage = screen.queryByText("Invalid Credentials");
    expect(errorMessage).toBeNull(); // safe & clear
})
- if you use getByText it would throw immediately and test would crash even though its actually correct but the error message wasnt supposed to be there yet

code
test("the spinner disappears after the loading", () => {
    render(<Greeting />);
    // spinner exists initially
    expect(screen.getByText("Loading...")).toBeInTheDocument();
    // wait for final render
    await screen.findByText("Hello, Immanuel");
    // now spinner should be gone
    expect(screen.queryByText("Loading...")).toBeNull();
})

Qn) If you use getByTestId and there are multiple elements matched, the first one is returned.
a) true
b) false

my-answer: i think you need to ask me two questions on this topic every time i ask you one. because weh, the depth of this topic is alarming. but i guess true. i think the first one is returned because it will go to the next line and not crash

correct-answer: false

explanation:
when you use getByTestId, React Testing Library will throw an error if more than one elements match the query. 
- it never just picks the first one. this is the way it allows you to recognize multiples

eg
code
App.jsx
export default function App(){
    return (
        <>
        <button data-testid="save-btn">Save</button>
        <button data-testid="save-btn">Save As</button>
        </>
    );
}

App.test.js
import { render, screen } from "@testing-library/react";
import App from "./App";

test("getByTestId with duplicates", () , => {
    render(<App />);
    screen.getByTestId("save-btn"); // throws an error
});
- to handle multiple matches, you must use getAllByTestId

code
const buttons = screen.getAllByTestId("save-btn");
expect(buttons).toHaveLength(2);

Qn) Why might relying too heavily on getByTestId be considered a bad practice in React Testing Library
a) Because it slows down tests
b) Because it ignores accessibility and real user behavior
c) Because its deprecated
d) Because it requires special configuration

answer: b) because it ignores accessibility and real user behavior

explanation:
RTL core philosophy is "the more your tests resemble how the app is used, the more confidence they give you"
- so it encourages using
getByRole("button", {name: /submit/i })
getByLabelText("Email")
getByText("Welcome")
before resorting to artificial selectors like data-testid

Qn) A good use case for the baseElement option for render is testing ..
a) animation effects
b) deeply-nested component trees
c) render props
d) portals

my-answer: now again, im seeing a question new to my eye. this is what we said we dont want. so let the two questions after each question i give you to be somehow broader in nature and the other one a deeper concept about this topic on the question

correct-answer: d portals

explanation:
- when you use render in React Testing Library, it creates a fake DOM using JSDOM, with a single container element usually document.body
- by default, all rendered components attach to that root.
- but some components like portal, render their children outside of the normal React tree, usually to another DOM node like a modal root.

Modal.js
import ReactDOM from "react-dom";

export default function Modal({ children }) {
    return ReactDOM.createPortal(
        children,
        document.getElementById("modal-root"); // a different part of DOM
    );
}
- when you test this, your modal wount show up in the default container because its rendered somewhere else
- so in your test you do this
import { render, screen } from "@testing-library/react";
import Modal from "./Modal";

test("renders modal in poral, () => {
    const modalRoot = document.createElement("div");
    modalRoot.setAttribute("id", "modal-root");
    document.body.appendChild(modalRoot);

    render(<Modal><p>Portal content</p></Modal>, {baseElement: document.body});

    expect(screen.getByText("Portal content")).toBeInTheDocument();
});
- so baseElement helps us to include elements outside the main container like modals or portals when searching the DOM.
Concept Purpose                                                               
container -  The default DOM node that your component renders into                                                              |
baseElement - The *root of the DOM tree* RTL should search in (useful when elements render outside the container — e.g. portals) 
- baseElement is useful for testing portals, modals and toasts which renders in another DOM

Qn) When testing portals, why might screen.debug() not show your portal content unless you pass { baseElement: document.body } ?
Because screen.debug() only logs the container by default. the portals render outside of that. 

Qn) Which render method would be most likely to be useful to check for memory leaks?
a) asFragment
b) cleanup
c) container
d) unmount

my-answer: again im seeing something i dont know. answer this and then two others. aim is to cover as much as possible in order not to hear somethingg new in an interview

correct-answer: d) unmount

explanation:
Memory Leaks in React tests
- a memory leak happens when a component or resource stays in memory after its supposed to be.
- this means, you have an ongoing setInterval, setTimeout, fetch() call and your component unmounts without cleaning it up.

code
function Timer()
{
    useEffect(() => {
        const interval = setTimeout(() => console.log("tick"), 1000);
        return () => clearInterval(interval);
    }, []);
    return <p>Running timer...</p>;
}

// if you forget to clear the interval, React might warn you:

- using render() from React Testing Library RTL, there are a few utility methods one of them being unmount()

import { render } from '@testing-library/react'
import Timer from './timer';

test("cleans up on unmount", () => {
    // we destructure on the fly instead of doing
    // render(< Timer />);
    const { unmount } = render(<Timer />);
    unmount(); // this simulates a component being removed
    // then check if there are no memory leak warnings or console errors
})
- so if your component did not clean up properly, unmount will help reveal that.
option - meaning - why not correct
- asFragment - Returns a snapshot-friendly DOM fragment for comparing renders - used for snapshot testing, not cleanup
- cleanup - global cleanup after tests (unmounts all components automatically) - used automatically by jest setup not for checking leaks
- container - the DOM node used for rendering - this is just a reference and is not related to memory cleanup

Qn) Difference between unmount() and cleanup()
- while cleanup() is called automatically, you need to define an unmount() method to check say for memory leaks
- while cleanup() affects all components rendered globally after tests, unmount() affects one component rendered by a specific render()

- render()- puts your component on stage
- unmount()- removes one actor
- cleanup()- cleans the whole stage after each performance

Qn) The rendered container property is the typical way to run queries and traverse the DOM tree
a) true
b) false

my-answer: true

correct-answer: false

explanation:
when you call React Testing Library's render() function, it returns an object with several utilities

code
const { container, getByText, queryByRole, asFragment, unmount } = render(<App />);
- one of those utilities is container, which is the root DOM node that RTL used to render your component  
- so yes you can use container to manually traverse the DOM
eg

code
expect(container.querySelector("button")).toBeInTheDocument();
- but again RTL philosophy is " the more your test resemble how your software is used, the more confidence they can give you "
- tests should use queries that mimic how a user interacts like
- getByRole("button", { name: /submit/i })
getByText("Save")
getByLabelText("Username")

code
expect(screen.getByRole("button", {name: /submit/i })).toBeInTheDocument();

"The container property gives you direct access to the underlying DOM, but its not the typical way to query elements in React Testing Library. RTL encourages using screen or semantic queries like getByRole or getByText, which reflect real user interactions and imporve test reliability"

Qn) What is the difference between using screen and destructuring queries from render()
both are valid but screen is preferred.
- it provides a global query scope. and makes your tests easier to read esp when you have multiple renders in one test file.

code 
// old way
const { getByText } = render(<App />);
getByText("Login");

//preferred way
render(<App />);
screen.getByText("Login");

Qn) When might it be acceptable to use container
- when youre testing non-accessible content or pure DOM structure
eg verifying CSS class presence or SVG structure
- youre snapshot testing markup with asFragment() or container.firstChild

eg
code
const { container } = render(<Icon />);
expect(container.querySelector("svg")).toBeInTheDocument();

Qn) Mocking useState isnt a good idea. This is an implementation detail and isn't public from outside the component
a) true
b) false

my-answer: ive never heard of mocking useState in RTL